[[mapping-chapter]]
= Mapping

Rich mapping support is provided by the `AerospikeMappingConverter`. `AerospikeMappingConverter` has a rich metadata model that provides a full feature set of functionality to map domain objects to Aerospike clusters and objects.The mapping metadata model is populated using annotations on your domain objects. However, the infrastructure is not limited to using annotations as the only source of metadata information. The `AerospikeMappingConverter` also allows you to map objects without providing any additional metadata, by following a set of conventions.

In this section we will describe the features of the `AerospikeMappingConverter`. How to use conventions for mapping objects to documents and how to override those conventions with annotation based mapping metadata.


[[mapping-conventions]]
== Convention based Mapping

`AerospikeMappingConverter` has a few conventions for mapping objects to documents when no additional mapping metadata is provided. The conventions are:


[[mapping.conventions.id-field]]
=== How the '_id' field is handled in the mapping layer

AerospikeDB requires that you have an '_id' field for all objects. If you don't provide one the driver will assign a ObjectId with a generated value. The "_id" field can be of any type the, other than arrays, so long as it is unique. The driver naturally supports all primitive types and Dates. When using the `AerospikeMappingConverter` there are certain rules that govern how properties from the Java class is mapped to this '_id' field.

The following outlines what field will be mapped to the '_id' document field:

* A field annotated with `@Id` (`org.springframework.data.annotation.Id`) will be mapped to the '_id' field.
* A field without an annotation but named 'id' will be mapped to the '_id' field.
* The default field name for identifiers is '_id' and can be customized via the `@Field` annotation.

[cols="1,2", options="header"]
.Examples for the translation of '_id'-field definitions
|===
| Field definition
| Resulting Id-Fieldname in AerospikeDB

| `String` id
| `_id`

| `@Field` `String` id
| `_id`

| `@Field('x')` `String` id
| `x`

| `@Id` `String` x
| `_id`

| `@Field('x')` `@Id` `String` x
| `_id`
|===

The following outlines what type conversion, if any, will be done on the property mapped to the _id document field.

* If a field named 'id' is declared as a String or BigInteger in the Java class it will be converted to and stored as a string. 
* If no field named 'id' is present in the Java class then an implicit '_id' file will be generated by the driver but not mapped to a property or field of the Java class.

When querying and updating `AerospikeTemplate` will use the converter to handle conversions of the `Query` and `Update` objects that correspond to the above rules for saving documents so field names and types used in your queries will be able to match what is in your domain classes.

[[mapping-configuration]]
== Mapping Configuration

Unless explicitly configured, an instance of `AerospikeMappingConverter` is created by default when creating a `AerospikeTemplate`. You can create your own instance of the `MappingAerospikeConverter` so as to tell it where to scan the classpath at startup your domain classes in order to extract metadata and construct indexes. Also, by creating your own instance you can register Spring converters to use for mapping specific classes to and from the database.

NOTE: AbstractAerospikeConfiguration will create a AerospikeTemplate instance and registered with the container under the name 'erospikeTemplate'.


Spring's AerospikeDB namespace enables you to easily enable mapping functionality in XML

.XML schema to configure AerospikeDB mapping support


[[mapping-usage-annotations]]
=== Mapping annotation overview

The MappingAerospikeConverter can use metadata to drive the mapping of objects to documents. An overview of the annotations is provided below

* `@Id` - applied at the field level to mark the field used for identiy purpose.
* `@Field` - applied at the field level and described the name of the field as it will be represented in the AerospikeDB BSON document thus allowing the name to be different than the fieldname of the class.

The mapping metadata infrastructure is defined in a seperate spring-data-commons project that is technology agnostic. Specific subclasses are using in the AerospikeDB support to support annotation based metadata. Other strategies are also possible to put in place if there is demand.

Here is an example of a more complex mapping.

[source,java]
----
public class Person<T extends Address> {

  @Id
  private String id;

  private Integer ssn;

  @Field("fName")
  private String firstName;

  private String lastName;

  private Integer age;

  private Integer accountTotal;

  private List<Account> accounts;

  private T address;


  public Person(Integer ssn) {
    this.ssn = ssn;
  }

  public Person(Integer ssn, String firstName, String lastName, Integer age, T address) {
    this.ssn = ssn;
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
    this.address = address;
  }

  public String getId() {
    return id;
  }

  // no setter for Id.  (getter is only exposed for some unit testing)

  public Integer getSsn() {
    return ssn;
  }

// other getters/setters ommitted
----
